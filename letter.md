---
breaks: false
---

# Voronezh SU, op. research, разбираемся с разногласиями

## День 1

1.  > Алгоритм Дейкстры
    > не работает с циклами, петлями,
    > неориентированными графами
    
    Алгоритм работает с произвольными орграфами
    с неотрицательными весами.
    Циклы не составляют проблемы,
    т.к. помеченные вершины
    в очередь уже не кладут.
    
    По этой же причине нет проблем с неорграфами.

## День 2

1.  > Dijkstra не решает задачу оптимизации
    
    Алгоритм решает задачу
    поиска в ориентированном графе
    с неотрицательными весами
    пути, из вершины $s$ в вершину $d$,
    с минимальным суммарным весом.
    Это --- задача оптимизации.
    
2.  > Принцип динамического программирования Беллмана
    
    ...говорит, что
    "оптимальное управление обладает тем свойством,
    что оно оптимально локально ---
    в каждый момент времени,
    независимо от оптимальности
    в другие моменты времени".
    
    В задаче поиска кратчайшего пути
    этот критерий формулируется в виде:
    $$d_j = \min\left\{
    d_i + w_{ij};
    \ {(i\rightsquigarrow j)\in E(G)}
    \right\},$$
    где $d_k$ --- длина кратчайшего пути
    из $s$ в $k$, для $k\in V(G)$.
    
    Если веса неотрицательны,
    то, очевидно, можно можно обойти граф в оптимальном
    порядке за $O((|V|+|E|)\log|V|)$ операций
    с помощью очереди с приоритетами.
    На каждой итерации правило Беллмана
    применяется к ближайшей к $s$ достижимой
    и непомеченной вершине.
    На каждой итерации сохраняется инвариант:
    посчитанное расстояние $d_i$
    для помеченной вершины $i$ ---
    кратчайшее возможное.
    Его невозможно уменьшить,
    из-за неотрицательности весов рёбер.
    
    Это --- алгоритм Дейкстры.
    
    Без ограничения на неотрицательность
    применение принципа Беллмана
    приводит к алгоритму Беллмана-Форда,
    который состоит в том,
    чтобы итеративно применять процедуру релаксации
    ко всем рёбрам графа
    о сходимости процесса.
    Поскольку несодержащий циклов
    путь в графе не может быть длиннее
    числа вершин в графе ---
    процедуру достаточно повторить $O(|V|)$ раз.
    
    1.  Чем эта схема отличается
        от изложенной на лекции? (Совпадает?)
        
3.  > На дискретной математике вам, наверное,
    > рассказывали алгоритмы,
    > но они не работают с петлями и пр.
    > 
    > ...
    > 
    > Ford-Fulkerson не работает с неорграфами

    В Ford-Fulkerson строится residual network.
    Ориентированное ребро
    из вершины $i$ в вершину $j$
    с весом $r_{ij} = c_{ij} - f_{ij}$
    в этом новом графе означает возможность
    увеличить поток $f_{ij}$ из $i$ в $j$ на $r_{ij}$ единиц
    прежде чем будет исчерпана ёмкость $c_{ij}$.
    Увеличение потока в прямом направлении
    уменьшает остаточную ёмкость в обратном направлении ---
    и наоборот.
    
    Отсюда следует наивный подход,
    известный как метод Форда-Фалкерсона:
    
    1.  Найти произвольный путь $\mathrm{source}\rightsquigarrow\mathrm{sink}$
        с неотрицательной ёмкостью.
        В этом пути найти bottleneck ---
        ор. ребро с наименьшей остаточной пропуской способностью $r_b$.
    2.  Уменьшить остаточную ёмкость в прямом направлении и увеличить в обратном --- на величину $r_b$.
    3.  Повторять, пока пути существуют.
    
    Исходная сеть --- ориентированный граф
    с ёмкостями $c_{ij}$ --- отображается
    в residual network тождественно.
    Ребро $i\rightsquigarrow j$
    с ёмкостью $c_{ij}$ в исходном графе
    означает возможность пусть в этом направлении
    поток $c_{ij}$.
    В обратном направлении мы можем пустить поток
    $c_{ji}$, если в графе есть ребро $j\rightsquigarrow i$, либо $0$.
    
    1.  Чем эта схема отличается
        от изложенной на лекции? (Совпадает?)
    2.  Петли и неориентированные графы
        вписываются в картину.